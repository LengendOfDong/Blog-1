# 1 前言
参考文章：https://www.toutiao.com/i6802767041762689544/

QPS：query per second
TPS：transaction per second

主要通过以下三点实现：
1. 高效的底层数据结构
2. IO多路复用模型
3. 事件机制

# 2 高效的数据结构
Redis 支持的几种高效的数据结构 string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）

# 3 IO多路复用
操作系统一般有四种IO模型：同步阻塞、同步非阻塞、多路复用、异步，redis底层主要调用了的操作系统IO多路复用的函数，极大节省了线程开支。

假设某一时刻与 Redis 服务器建立了 1 万个长连接，对于阻塞式 IO 的做法就是，对每一条连接都建立一个线程来处理，那么就需要 1万个线程，**同时根据我们的经验对于 IO 密集型的操作我们一般设置，线程数 = 2 * CPU 数量 + 1，对于 CPU 密集型的操作一般设置线程 = CPU 数量 + 1**，当然各种书籍或者网上也有一个详细的计算公式可以算出更加合适准确的线程数量，但是得到的结果往往是一个比较小的值，像阻塞式 IO 这也动则创建成千上万的线程，系统是无法承载这样的负荷的更加弹不上高效的吞吐量和服务了。

而多路复用 IO 模型的做法是，用一个线程将这一万个建立成功的链接陆续的放入 event_poll（这个应该是redis的内部实现），event_poll 会为这一万个长连接注册回调函数，当某一个长连接准备就绪后（建立建立成功、数据读取完成等），就会通过回调函数写入到 event_poll 的就绪队列 rdlist 中(目的就是把channel对象标记为就绪的状态)，这样这个单线程就可以通过读取 rdlist 获取到需要的数据。

流程示意图如下：
![redis IO多路复用示意图](https://p1.pstatp.com/large/pgc-image/a2eada5a14e9463185acf22b4b9ae8ef)

# 4 事件机制


