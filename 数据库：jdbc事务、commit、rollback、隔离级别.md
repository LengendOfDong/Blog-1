# 1 事务

事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务时一系列的DML、DFL、DCL语句的**有序**集合，事务具有4个特性：ACID，分别是：

原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

一致性（Consistency）：事务前后数据的完整性必须保持一致。

隔离性（Isolation）：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

持久性（Duration）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

## 1.1 原子性

以A账户向B账户转100块  这个事务 为例，事务中的动作包括A的钱扣100和B的钱增加100。如果对B的账户增加100块是出现了异常，则整个事务回滚（未commit，DML语句只是写入日志并没写入表），撤销在日志中  该事务的所有操作。如果所有的操作都成功，则操作从日志中持久到对表的修改。

原子性表现在，**事务中的所有的sql操作，要么同时生效到表中，要么同时从日志中全部撤销出来。**

## 1.2 一致性

事务完成后，符合逻辑运算

## 1.3 持久性

表示事务结束（结束的标志是commit和rollback，主动链接不算结束标志）后的数据，不会因为外界原因导致数据丢失。

如果在事务还没有提交（只是写入日志，为生效到表中），服务器宕机或者断电（connection突然断开），那么重启数据库以后，表的状态应该为  事务开始之前的状态。
 如果在事务已经提交（写入了日志和表），服务器宕机或者断电，那么重启数据库以后，表的状态应该为 事务成功后的状态。

## 1.4 隔离性

针对多个事务同时对数据库操作，主要是允许其他事务对本事务的影响程度，其他事务对本事务的影响程度就是当前事务开始定义的隔离性。

因为事务的隔离性级别带来的常见三个问题为：

* 脏读

指一个事务读取了另外一个事务未提交的数据，也就是读取了，别的事务写到日志里的一系列动作，但是，别的事务有可能会rollback。

比如：

1、Mary的原工资为1000, 财务人员将Mary的工资改为了8000(但未提交事务)         

2、Mary读取自己的工资 ，发现自己的工资变为了8000，开心的一批

3、而财务发现操作有误，回滚了事务，Mary的工资又变为了1000

Mary记取的工资数8000是一个脏数据

  解决办法：如果在第一个事务提交前，任何其他事务不可读取其修改过的值，则可  以避免该问题。

* 不可重复读

在一个事务内读取表中的某一行数据的某一个或者多个字段，多次读取结果不同。（这个不一定是错误，只是某些场合不对）。也就是，在别的事务提交前后，读取了同一行的数据，恰好别的事务修改了该行，两次读取的结果不同，造成**读取操作不具有幂等性了**。

比如：

1、在事务1中，Mary 读取了自己的工资为1000,操作并没有完成

2、在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.

3、在事务1中，Mary 再次读取自己的工资时，工资变为了2000

解决办法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。也就是，将当前事务隔离级别设置为 TRANSACTION_READ_COMMITTED。

* 幻读

当前事务正在读取某些行的范围时，如果有另外的事务对这些行进行了**插入或删除**操作。比如，事务第一次读的行范围中的一行或者多行已不存在于第二次读或后续读取中，因为该行已被其它事务删除。同样，由于其它事务的插入操作，事务的第二次或后续读显示有一行相比于原始读取的行，是多出来的。

举个例子， 目前工资为1000的员工有10人。

1、事务1，读取所有工资为1000的员工，显然是10条记录了

2、这时事务2向employee表插入了一条员工记录，工资也为1000

3、事务1再次读取所有工资为1000的员工 共读取到了11条记录 

解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以 **添加/删除** 新数据，则可避免该问题。也即是隔离级别设置为，TRANSACTION_SERIALIZABLE

* 更新丢失问题

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。**最后的更新将重写由其它事务所做的更新，这将导致数据丢失。** 　　

比如：事务A和事务B同时修改某行的值，两者先同时读取了原始的该行数据，事务A先将数值改为1并提交，这时事务B将数值改为2并提交，事务A所做的更新将会丢失。

解决办法：对行加锁，只允许并发一个更新事务



为了解决事务的并发问题，数据库的标准隔离级别有四种，以JDBC中 connection的隔离级别参数为例：

| 设置                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| TRANSACTION_SERIALIZABLE     | 指示不可以发生脏读、不可重复读和幻读的常量。                 |
| TRANSACTION_REPEATABLE_READ  | 指示不可以发生脏读和不可重复读的常量；幻读可以发生。         |
| TRANSACTION_READ_UNCOMMITTED | 指示可以发生脏读 (dirty read)、不可重复读和幻读 (phantom read) 的常量。 |
| TRANSACTION_READ_COMMITTED   | 指示不可以发生脏读的常量；不可重复读和虚读可以发生。         |







//=============================================

事务的焦点问题是其隔离级别和不同隔离级别带来的并发问题：

- 隔离级别
   ACID这4个特征中，最难理解的是隔离性。在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。4个隔离级别分别是：读未提交（READ_UNCOMMITTED）、读已提交（READ_COMMITTED）、可重复读（REPEATABLE_READ）、顺序读（SERIALIZABLE）。
- 事务并发引起的问题
   数据库在不同的隔离性级别下并发访问可能会出现以下几种问题：脏读（Dirty Read）、不可重复读（Unrepeatable Read）、幻读（Phantom Read）。

DML（data manipulation language）：
它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言

DDL（data definition language）：
DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用

DCL（Data Control Language）：
是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL

