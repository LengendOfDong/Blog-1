# 1 前言
参考文章   深入解析Mysql 主从同步延迟原理及解决方案     https://www.cnblogs.com/cnmenglang/p/6393769.html

# 2 mysql分布式方案
MySQL的主从同步是一个很成熟的架构，优点为：

（1）在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;

（2）在从服务器从主服务器取“备份”文件，可避免备份期间影响主服务器服务;

（3）当主服务器出现问题时，可以切换到从服务器。

## 2.1 主从复制原理
**老版本**mysql的主从复制是单线程的操作，主库对所有DDL和 DML会产生binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率很高。根据去回来的binlog，slave的Slave_SQL_Running线程将主库的DDL和DML操作在slave实施。

## 2.2 主从延迟产生原因
DML和DDL的**IO操作**是随机（不是SQL的执行顺序是随机的），不是顺序的，成本较高，甚至在binlog操作实施的过程中，slave上的查询可能会有事务锁，由于Slave_SQL_Running也是单线程的，所以单线程中的一个DDL或者DML卡住了，后续的DDL或者DML就不得不等待当前这个执行完才会继续执行，这就导致了延时。

同时还有别的原因，如果是一个很复杂的DML或者DDL操作，主库是可以多线程并发进行的，多线程处理速度本来就快，再加上，从库由于是通过一个单线程Slave_SQL_Running进行这些复杂的DML或者DDL操作，又比主库慢了很多。

**值得注意的是，**mysql-5.6.3已经支持了多线程的主从复制，原理和阿里奇数专家丁奇的实现类似，丁奇的是以表做多线程进行出从复制。Oracle使用的是以数据库(schema)为单位做多线程，不同的库可以使用不同的复制线程。

总结一下，两个主要原因：

1. 主库的DML和DDL很复杂，或者 TPS巨多时，超过了从库的线程处理能力，会增大主动延迟

2. 从库中执行的事务性查询可能会导致锁等待

## 2.3 解决方案
1、优化语句，能DDL和DML快速执行

2、优化部署配置。还有就是主库是写，对数据安全性较高，比如 sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog，innodb_flushlog也 可以设置为0来提高sql的执行效率。

3、使用比主库更好的硬件设备作为slave。
