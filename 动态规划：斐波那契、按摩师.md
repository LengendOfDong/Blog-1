# 1 动态规划简介

有几个重要的点：

1. 动态规划说到底就是求通项公式，要找到一个合适的通项公式来表示状态转移
2. 后效性，几乎所有的后效性都可以通过增加一个数据维度或者多考虑前几个状态来实现后效性的消除
3. 动态规划的实现，包括但不限于，从大小到小的递归+备忘录实现，也有从小到大的递推+填表实现



# 2 斐波那契数列


```java
package com.zte.动态规划专题;


import java.util.HashMap;
import java.util.Map;

//求第N个斐波那契数
public class Fiber {
    public static int Fiber_递归(int n) {
        System.out.println("input:" + n);
        if (1 == n || 2 == n) {
            return 1;
        } else {
            return Fiber_递归(n - 1) + Fiber_递归(n - 2);
        }

    }

    public static long Fiber_DP(long n, Map<Long, Long> record) {
        if (record.containsKey(n)) {
            return record.get(n);
        }

        if (1L == n || 2L == n) {
            System.out.println("add:" + n);
            record.put(n, 1L);
            return 1L;
        }

        long result = Fiber_DP(n - 1, record) + Fiber_DP(n - 2, record);
        System.out.println("add:" + n);
        record.put(n, result);
        return result;
    }

    public static void main(String[] args) {
//        System.out.println(Fiber_递归(10));
        Map<Long, Long> record = new HashMap<>();
        Fiber_DP(50, record);
        System.out.println(record);

    }

}
```



# 3 leetcode 按摩师

```java
package default_package.leetcode按摩师;

/*
一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

注意：本题相对原题稍作改动



示例 1：

输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。

示例 2：

输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。

示例 3：

输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/the-masseuse-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class Main {
    public int massage(int[] nums) {

        int length = nums.length;

        if (0 == length) {
            return 0;
        }

        int[] result = new int[length];

        for (int i = 0; i < length; i++) {
            if (0 == i) {
                result[i] = nums[i];
                continue;
            }

            if (1 == i) {
                result[i] = Math.max(nums[0], nums[1]);
                continue;
            }

            result[i] = Math.max(result[i - 1], result[i - 2] + nums[i]);

        }

        return result[length - 1];
    }
}

```

