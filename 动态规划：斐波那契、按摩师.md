# 1 动态规划简介

有几个重要的点：

1. 动态规划说到底就是求通项公式，要找到一个合适的通项公式来表示状态转移
2. 后效性，几乎所有的后效性都可以通过增加一个数据维度或者多考虑前几个状态来实现后效性的消除
3. 动态规划的实现，包括但不限于，从大小到小的递归+备忘录实现，也有从小到大的递推+填表实现



# 2 斐波那契数列


```java
package com.jeasonchan.动态规划专题;


import java.util.HashMap;
import java.util.Map;

//求第N个斐波那契数
public class Fiber {
    public static int Fiber_递归(int n) {
        System.out.println("input:" + n);
        if (1 == n || 2 == n) {
            return 1;
        } else {
            return Fiber_递归(n - 1) + Fiber_递归(n - 2);
        }

    }

    public static long Fiber_DP(long n, Map<Long, Long> record) {
        if (record.containsKey(n)) {
            return record.get(n);
        }

        if (1L == n || 2L == n) {
            System.out.println("add:" + n);
            record.put(n, 1L);
            return 1L;
        }

        long result = Fiber_DP(n - 1, record) + Fiber_DP(n - 2, record);
        System.out.println("add:" + n);
        record.put(n, result);
        return result;
    }

    public static void main(String[] args) {
//        System.out.println(Fiber_递归(10));
        Map<Long, Long> record = new HashMap<>();
        Fiber_DP(50, record);
        System.out.println(record);

    }

}
```



# 3 leetcode 按摩师

```java
package default_package.leetcode按摩师;

/*
一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

注意：本题相对原题稍作改动



示例 1：

输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。

示例 2：

输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。

示例 3：

输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/the-masseuse-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class Main {
    public int massage(int[] nums) {

        int length = nums.length;

        if (0 == length) {
            return 0;
        }

        int[] result = new int[length];//存储前面的记录用数据结构

        //采用递推的方式从底部开始填充，和前面的斐波那契数列采用的递归略有不同
        for (int i = 0; i < length; i++) {
            if (0 == i) {
                result[i] = nums[i];
                continue;
            }

            if (1 == i) {
                result[i] = Math.max(nums[0], nums[1]);
                continue;
            }

            //动态规划的核心！
            //此处采用一维方式抵消后效性，下面可以补充增加一个维度以抵消后效性的通项公式
            result[i] = Math.max(result[i - 1], result[i - 2] + nums[i]);

        }

        return result[length - 1];
    }
}

```

## 3.1 增加一个维度抵消后效性

# 4 字母数组的最大累加问题
```java
package com.jeasonchan.字数组的最大累加问题;


/*
牛客网
 给定一个数组arr，返回子数组的最大累加和
例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.
[要求]
时间复杂度为O(n)O(n)O(n)，空间复杂度为O(1)O(1)O(1)

输入：

7
1 -2 3 5 -2 6 -1


 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        InputStreamReader inputStreamReader = new InputStreamReader(System.in);
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);

        String oneLine = "";

        while (null != (oneLine = bufferedReader.readLine())) {
//            System.out.println("oneLine:" + oneLine);

            //完成数据采集
            int length = Integer.parseInt(oneLine.trim());
            String arrayLine = bufferedReader.readLine();
            String[] stringArray = arrayLine.split(" ");
            int[] array = new int[length];
            for (int i = 0; i < length; i++) {
                array[i] = Integer.parseInt(stringArray[i]);
                //为了优化时间复杂度，可以在这个循环中就直接开始进行动态规划的递推
            }


            //开始计算最大值
            System.out.println(getMaxSum(array));

            break;
        }


    }


    public static int getMaxSum(int[] array) {
        int length = array.length;
        int[] temp = new int[length];

        if (0 == length) {
            return 0;
        }

        temp[0] = Math.max(0, array[0]);

        for (int index = 1; index < length; index++) {
            temp[index] = Math.max(temp[index - 1], temp[index - 1] + array[index]);
        }
        return temp[length - 1];

    }

}
```

