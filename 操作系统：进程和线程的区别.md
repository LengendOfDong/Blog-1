# 1 进程和线程的区别

**下面细说背景**：
CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

**一个最最基础的事实：时间切片**：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。

**一个必须知道的事实**：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的**程序上下文**。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是**保存程序上下文**，因为这个是下次他被CPU临幸的运行环境，必须保存。

**串联起来的事实**：前面讲过的，在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：

先加载程序A的上下文——然后开始执行A——保存程序A的上下文——调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文……

进程和线程就是这样的背景出来的，**两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。**

**进程就是包括上下文切换的、程序执行时间的总和 = CPU加载上下文+CPU执行+CPU保存上下文**

**线程是什么呢？**

进程的颗粒度太大，每次都要有上下文的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：

程序A得到CPU ——>CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段——>最后CPU保存A的上下文。

这里三个线程a，b，c的执行是共享了A的上下文的，CPU在执行的时候没有进行上下文切换的。这**里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。**



## 1.1 小结

**进程就是包括上下文切换的、程序执行时间的总和 = CPU加载上下文+CPU执行+CPU保存上下文**。

**线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。**

**进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。**

## 1.2 补充

* 线程必须在进程下行进，且之存在于进程的概念之中。

* 一个进程可以包含多个线程

* 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘），但是，还是有办法的

* 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）

* 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）

* **进程间不会相互影响，一个线程挂掉将导致整个进程挂掉**（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）

* **进程可以拓展到多机，线程最多拓展在多核**（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）

* 进程使用的**内存地址可以上锁**，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－**"互斥锁"**

* 进程使用的**内存地址可以限定使用量**（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－**“信号量”**

# 2 线程间的同步方式

同步，分为两种情况：

* 同步共享资源，各种锁机制、CAS等  https://www.cnblogs.com/XHJT/p/3897440.html
* 同步多个任务的执行，CountDownLatch    https://blog.csdn.net/zbc1090549839/article/details/53464902



# 3 进程间通信方式

https://blog.csdn.net/Zhxin606a/article/details/88540399



# 4 线程的调度方式

抢占式调度：（由系统决定时间切片）

指的是每条线程执行的时间、线程的切换都由系统控制。系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。**在这种机制下，一个线程的堵塞不会导致整个进程堵塞。**

协同式调度：（线程间相互协同串行执行）

指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。

Java线程调度方式：https://blog.csdn.net/weixin_34362875/article/details/93318053