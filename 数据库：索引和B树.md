# 1 摘要

**为什么要索引**？

没有索引的话，查找时间时O(n)



**各种数据结构的索引优劣**？

（索引是建立在排序的基础上的）

链表，初步排序后，通过链表数据结构的搜索时间大大缩短，但还是O(n)。

数组，可使用二分法了，时间是O(logN)，但是，增删数据很慢。

平衡二叉树（也就是，红黑树），二叉树的遍历和深度机器相关，平衡二叉树的时间是O(log2N)，很不错，但是适应不了索引极大的情况，因为，物理实现其实是数组，频繁IO时间仍然很长。红黑树（平衡二叉树）结构，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。

B树，充分利用了磁盘预读功能而**创造**的一种数据结构。**B树的每个节点可以存储多个关键字**，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，**树的深度就会非常的小**。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。

B+树，B树的变种。B树：有序数组+平衡多叉树；B+树：有序数组**链表**+平衡多叉树；B+树的**关键字全部存放在叶子节点**中，**非叶子节点用来做索引**，而叶子节点中有一个指针指向一下个叶子节点（链表）。数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。



总结一下，B+树成为主流大型数据库索引的原因：

* 带顺序访问指针的B+Tree

B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。

这样做是为了提高区间效率，例如查询key为从18到49的所有数据记录，当找到18后，只要顺着节点和指针顺序遍历就可以以此向访问到所有数据节点，极大提高了区间查询效率。

* 大大减少磁盘I/O读取

数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点需要一次I/O就可以完全载入。





## 1.1 常识补充

mysql的B+树索引 查找使用了二分查找，redis 跳表也使用了二分查找法，kafka查询消息日志也使用了二分查找法，二分查找法时间复杂度O(logn);

参考：**redis的索引底层的 跳表原理 实现** [聊聊Mysql索引和redis跳表 ---redis的跳表原理 时间复杂度O(logn)(阿里)](https://www.cnblogs.com/aspirant/p/11475295.html)

参考：[kafka如何实现高并发存储-如何找到一条需要消费的数据(阿里)](https://www.cnblogs.com/aspirant/p/11481332.html)

参考：二分查找法：[各种排序算法的时间复杂度和空间复杂度(阿里)](https://www.cnblogs.com/aspirant/p/11470971.html)

在MySQL中，主要有四种类型的索引，分别为：

* B-Tree索引，包括B+ Tree；B树：有序数组+平衡多叉树； 
  B+树：有序数组**链表**+平衡多叉树；
* Hash索引，
* Fulltext索引(\**MyISAM 表\**)
* R-Tree索引，本文讲的是B-Tree索引。

Mysql可以配置不同的存储引擎，各个存储引擎的默认索引是不同的：

(a) Inodb存储引擎 默认是 B+Tree索引；**B+Tree是mysql使用最频繁的一个索引数据结构，是Inodb和Myisam存储引擎模式的索引类型**。相对Hash索引，B+Tree在查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。

(b) MyISAM 存储引擎 默认是Fulltext索引；

(c)Memory 存储引擎 默认 Hash索引；mysql中，只**有Memory(Memory表只存在内存中，断电会消失，适用于临时表)存储引擎显示支持Hash索引，是Memory表的默认索引类型**，尽管Memory表也可以使用B+Tree索引。Hash索引把数据以hash形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为hash结构，每个键只对应一个值，而且是散列的方式分布。所以它并不支持范围查找和排序等功能。



# 2 各种数据结构作为索引的利弊分析



# 3 索引原理

## 3.1  索引原理

索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等

**本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。**

数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到**搜索树**，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

##  3.2 磁盘IO与预读

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，**当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内**，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。

每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。

**因为存在局部性原理，为了利用局部性原理来优化计算机的IO性能，有了预读取的做法。**

## 3.3 B+树索引的数据结构

任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度（树的遍历复杂度和数的高度正相关）可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。

再回顾一下B+树的两个特点：

* 利用了IO的预读，一个节点存放多个索引，并且大小等于1个page
* 叶子节点采用顺序链表，便于对字段属性进行范围搜索

![索引原理B+树](.\resources\索引原理B+树.png)

如上图，是一颗b+树，关于b+树的定义可以参见[B+树](http://zh.wikipedia.org/wiki/B%2B树)，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。**非叶子节点不一定存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。**

### 3.3.1 select * from table where age=29;

假设上图是一个小区的人员统计表 的 年龄字段的索引，数字代表年龄大小，现在要找所有29岁的人，则要查找数据项29，使用sql语句:

```sql
select * from table where age=29;
```

那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用**二分查找确定**29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

sql一般是在操作人员下发create index后自动建立索引，建立恰当的非叶子节点的索引边界是十分重要的，一般要保证被查找的属性均匀分布。

### 3.3.2 B+树的性质

1. **索引字段要尽量的小**：

意思是，表的字段大小（下面，成为“数据项”）在表达清晰的情况下，能精简就精简，占用空间越少越好。比如，表示人的年龄，只需要0-200范围内的整数即可，用不到bigint。

通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 /数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，**如果数据项占的空间越小，数据项的数量越多，树的高度越低。**这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据项放到叶子节点而不是内层节点，一旦放到内层节点（也就是 非叶子节点，非叶子节点只放用于辅助二分查找的 数据项），磁盘块的数据项会大幅度下降，导致树增高。当单个节点内的数据项等于1时将会退化成线性表。

所以，对某一字段生成的索引，包含了两种：

* 不是真实存在的、仅用于辅助二分查找的属性值，放在内层节点
* 真实存在的属性值，放在叶子节点

2. **索引的最左匹配特性（即从左往右匹配）**：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

## 3.4 全文索引（FULLTEXT）

**mysql的 myISAM搜索引擎默认的索引类型=全文索引（FULLTEXT）**。

MySQL从3.23.23版开始支持全文索引，**fulltext索引仅可用于 MyISAM 表**；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE  INDEX被添加。

### 3.4.1 全文索引最适用的场景

对文本字段上的创建普通的索引，只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作。如果字段里存放的是由几个、甚至是多个单词构成的较大段文字，普通索引就没什么作用了。因为，这种查询场景下的sql语句往往以LIKE %word%的形式出现，这对MySQL来说很复杂，如果需要处理的数据量很大，响应时间就会很长。这时，全文索引(full-text  index)可以大显身手的地方。在生成这种类型的索引时，MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数据记录。全文索引即可以随数据表一同创建，也可以等日后有必要时再使用下面这条命令添加： 

```sq
ALTER TABLE table_name ADD FULLTEXT(column1, column2) 
```

有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。下面是这类查询命令的基本语法：

```sql
SELECT * FROM table_name 
WHERE MATCH(column1, column2) AGAINST('word1', 'word2', 'word3');
# 上面这条命令将把column1和column2字段里有word1、word2和word3的数据记录全部查询出来。 
```

对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。

参考：[Mysql索引详解及优化(key和index区别)](https://www.cnblogs.com/pcyy/p/7943759.html) 

## 3.5  索引使用注意事项

1. 不要滥用索引

* 索引提高查询速度，却会降低更新表的速度，因为更新表时，mysql不仅要更新数据，保存数据，还要更新索引，保存索引

* 索引会占用磁盘空间 

2. 索引不会包含含有NULL值的列

复合索引只要有一列含有NULL值,那么这一列对于此符合索引就是无效的，因此我们在设计数据库设计时不要让字段的默认值为NULL。 

3，MySQL查询只是用一个索引

如果where字句中使用了索引的话，那么order by中的列是不会使用索引的 

4，like

like '%aaa%'不会使用索引而like "aaa%"可以使用索引