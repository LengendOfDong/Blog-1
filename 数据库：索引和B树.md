# 1 摘要

**为什么要索引**？

没有索引的话，查找时间时O(n)



**各种数据结构的索引优劣**？

（索引是建立在排序的基础上的）

链表，初步排序后，通过链表数据结构的搜索时间大大缩短，但还是O(n)。

数组，可使用二分法了，时间是O(logN)，但是，增删数据很慢。

平衡二叉树（也就是，红黑树），二叉树的遍历和深度机器相关，平衡二叉树的时间是O(log2N)，很不错，但是适应不了索引极大的情况，因为，物理实现其实是数组，频繁IO时间仍然很长。红黑树（平衡二叉树）结构，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。

B树，充分利用了磁盘预读功能而**创造**的一种数据结构。**B树的每个节点可以存储多个关键字**，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，**树的深度就会非常的小**。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。

B+树，B树的变种。B树：有序数组+平衡多叉树；B+树：有序数组**链表**+平衡多叉树；B+树的**关键字全部存放在叶子节点**中，**非叶子节点用来做索引**，而叶子节点中有一个指针指向一下个叶子节点（链表）。数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。



总结一下，B+树成为主流大型数据库索引的原因：

* 带顺序访问指针的B+Tree

B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。

这样做是为了提高区间效率，例如查询key为从18到49的所有数据记录，当找到18后，只要顺着节点和指针顺序遍历就可以以此向访问到所有数据节点，极大提高了区间查询效率。

* 大大减少磁盘I/O读取

数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点需要一次I/O就可以完全载入。





## 1.1 常识补充

mysql的B+树索引 查找使用了二分查找，redis 跳表也使用了二分查找法，kafka查询消息日志也使用了二分查找法，二分查找法时间复杂度O(logn);

参考：**redis的索引底层的 跳表原理 实现** [聊聊Mysql索引和redis跳表 ---redis的跳表原理 时间复杂度O(logn)(阿里)](https://www.cnblogs.com/aspirant/p/11475295.html)

参考：[kafka如何实现高并发存储-如何找到一条需要消费的数据(阿里)](https://www.cnblogs.com/aspirant/p/11481332.html)

参考：二分查找法：[各种排序算法的时间复杂度和空间复杂度(阿里)](https://www.cnblogs.com/aspirant/p/11470971.html)

在MySQL中，主要有四种类型的索引，分别为：

* B-Tree索引，包括B+ Tree；B树：有序数组+平衡多叉树； 
  B+树：有序数组**链表**+平衡多叉树；
* Hash索引，
* Fulltext索引(\**MyISAM 表\**)
* R-Tree索引，本文讲的是B-Tree索引。

Mysql可以配置不同的存储引擎，各个存储引擎的默认索引是不同的：

(a) Inodb存储引擎 默认是 B+Tree索引；**B+Tree是mysql使用最频繁的一个索引数据结构，是Inodb和Myisam存储引擎模式的索引类型**。相对Hash索引，B+Tree在查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。

(b) MyISAM 存储引擎 默认是Fulltext索引；

(c)Memory 存储引擎 默认 Hash索引；mysql中，只**有Memory(Memory表只存在内存中，断电会消失，适用于临时表)存储引擎显示支持Hash索引，是Memory表的默认索引类型**，尽管Memory表也可以使用B+Tree索引。Hash索引把数据以hash形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为hash结构，每个键只对应一个值，而且是散列的方式分布。所以它并不支持范围查找和排序等功能。



# 2 索引

# 3 索引原理