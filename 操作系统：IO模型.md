# 1 参考文章
操作系统IO操作模式   https://blog.csdn.net/u012474535/article/details/80733118

操作系统之多路复用IO总结   https://blog.csdn.net/mortal5/article/details/80952722?depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromBaidu-23&utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromBaidu-23

漫谈五种IO模型（主讲IO多路复用）    https://www.jianshu.com/p/6a6845464770

Java NIO 看这一篇就够了  https://blog.csdn.net/u011381576/article/details/79876754

Java NIO IO和NIO的区别   https://www.cnblogs.com/xiaoxi/p/6576588.html

Java NIO 理解分析和基本使用  https://my.oschina.net/u/4347428/blog/3220262


# 2 关键概念理解
同步：发起一个调用，得到结果才返回。

异步：调用发起后，调用直接返回；调用方主动询问被调用方获取结果，或被调用方通过回调函数。

同步阻塞调用：调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

同步非阻塞调用：在不能立刻得到结果之前，该调用不会阻塞当前线程。



**同步才有阻塞和非阻塞之分；**

阻塞与非阻塞关乎如何对待事情产生的结果（阻塞：不等到想要的结果我就不走了）

# 3 进程状态转换
就绪状态 -> 运行状态：处于就绪状态的进程被调度后，获得CPU资源（分派CPU时间片），于是进程由就绪状态转换为运行状态。

运行状态 -> 就绪状态：处于运行状态的进程在时间片用完后，不得不让出CPU，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。

运行状态 -> 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。**IO阻塞会隐式让出时间切片！！！**

阻塞状态 -> 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。

![进程状态图](.\resources\进程状态图)

# 4 操作系统IO模型

操作系统的IO模型，主要用在高级语言的底层实现中，在Java中，IO和NIO所使用的底层IO模型是不同的，但是，在代码上并没有十分大的差别，比如，同步非阻塞IO模型，客户端确实不断轮询socket，查看数据是否已经可读，但这一过程并不需要Java的使用者来实现。

作为开发者，我们应该了解知道各种IO模型的基本原理，来应对流量需求、IO需求越来越大的互联网，从而优化server端程序。



## 4.1 同步阻塞模型

同步阻塞IO模型是最建安的IO模型，用户线程在内核进行IO操作时被阻塞，同时会隐式触发用户线程放弃当前的时间切片。

![同步阻塞IO时序图](.\resources\同步阻塞IO时序图.png)

如图所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，**然后将接收的数据拷贝到用户空间**，完成read操作。

用户线程使用同步阻塞IO模型的伪代码描述为：

    {
        read(socket, buffer);
        process(buffer);
    }

即用户需要等待read将socket（这里使用了进程间的通信方式：套接字）中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。


## 4.2 同步非阻塞模型

同步非阻塞IO是在同步阻塞IO的基础上，**将socket设置为NONBLOCK**。这样做用户线程可以在发起IO请求后可以立即返回。

![同步非阻塞IO时序图](.\resources\同步非阻塞IO时序图.png)

如图所示，由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，并且，**用户线程需要不断主动地发起IO请求**，直到数据到达后，才真正读取到数据，继续执行。

用户线程使用同步非阻塞IO模型的伪代码描述为：

    {
        while(read(socket, buffer) != SUCCESS);
        process(buffer);
    }

即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。








## 4.3 IO多路复用


IO多路复用，相当于复用了一个IO中间件，能够在一个线程中处理多个IO请求，把可读的socket告诉用户进程；而传统的处理多个IO的方式是，new出和IO请求同样数量的线程，再让各个线程以同步、异步的IO模型去处理各自负责的的IO

Java NIO（多路复用IO模型） 其实也是阻塞IO模型，只不过解决了同步IO带来的一个线程处理一个IO的 多线程过多导致的server端压力过大问题。基于IO多路复用这个思想，典型的产品、实践：Nginx、Netty

## 4.4 异步IO
